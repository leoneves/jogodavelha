<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 5. Local search solver</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Drools Planner User Guide"/><link rel="up" href="index.html" title="Drools Planner User Guide"/><link rel="prev" href="ch04.html" title="Chapter 4. Score calculation with a rule engine"/><link rel="next" href="ch06.html" title="Chapter 6. Benchmarking and tweaking"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch04.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch06.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1759"/>Chapter 5. Local search solver</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch05.html#d0e1762">5.1. Overview</a></span></dt><dt><span class="section"><a href="ch05.html#d0e1810">5.2. A move</a></span></dt><dt><span class="section"><a href="ch05.html#d0e1964">5.3. Move generation</a></span></dt><dt><span class="section"><a href="ch05.html#d0e1996">5.4. A step</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2066">5.5. Getting stuck in local optima</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2089">5.6. Deciding the next step</a></span></dt><dd><dl><dt><span class="section"><a href="ch05.html#d0e2128">5.6.1. Selector</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2142">5.6.2. Acceptor</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2247">5.6.3. Forager</a></span></dt></dl></dd><dt><span class="section"><a href="ch05.html#d0e2306">5.7. Best solution</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2321">5.8. Termination</a></span></dt><dd><dl><dt><span class="section"><a href="ch05.html#d0e2339">5.8.1. TimeMillisSpendTermination</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2357">5.8.2. StepCountTermination</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2364">5.8.3. ScoreAttainedTermination</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2375">5.8.4. UnimprovedStepCountTermination</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2384">5.8.5. Combining Terminations</a></span></dt><dt><span class="section"><a href="ch05.html#d0e2397">5.8.6. Another thread can ask a Solver to terminate early</a></span></dt></dl></dd><dt><span class="section"><a href="ch05.html#d0e2421">5.9. Using a custom Selector, Acceptor, Forager or Termination</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1762"/>5.1. Overview</h2></div></div></div><p>In number of possible solutions for a planning problem can be mind blowing. For example:</p><div class="itemizedlist"><ul><li><p>4 queens has 256 possible solutions (<code class="literal">n ^ n</code>) and 2 optimal solutions.</p></li><li><p>5 queens has 3125 possible solutions (<code class="literal">n ^ n</code>) and 1 optimal solution.</p></li><li><p>8 queens has 16777216 possible solutions (<code class="literal">n ^ n</code>) and 92 optimal solutions.</p></li><li><p>Most real-life planning problems have an incredible number of possible solutions and only 1 or a few
        optimal solutions.</p></li></ul></div><p>An algorithm that checks every possible solution (even with pruning) can easily run for billions of years on a
    single real-life planning problem. Most of the time, we are happy with a feasible solution found in a limited amount
    of time. Local search tends to find a feasible solution relatively fast. Because it acts very much like a human, it
    is also pretty natural to program.</p><p>Local search solves a problem by making a move on the current solution which changes it into a better
    solution. It does that high number of iterations untill its time runs out and it is satisfied with the solution. It
    starts with the starting solution.</p><p>A local search algorithm and the drools rule engine turn out to be a really nice combination, because:</p><div class="itemizedlist"><ul><li><p>A rule engine such as Drools Expert is <span class="bold"><strong>great for calculating the score</strong></span> of
        a solution of a planning problem. It make it easy to add additional soft or hard constraints such as "a teacher
        shouldn't teach more then 7 hours a day". However it tends to be too complex to use to actually find new
        solutions.</p></li><li><p>A local search algorithm is <span class="bold"><strong>great at finding new improving solutions</strong></span> for
        a planning problem, without brute-forcing every possibility. However it needs to know the score of a solution
        and normally offers no support in calculating that score.</p></li></ul></div><p>Drools Planner's local search implementation combines both. On top of that, it also offers additional support
    for benchmarking, etc.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1810"/>5.2. A move</h2></div></div></div><p>A move is the change from a solution A to a solution B. For example, below you can see a single move on the
    starting solution of 4 queens that moves a single queen to another row:</p><div class="figure"><a id="d0e1815"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Local_search/singleMoveNQueens04.png" alt="A single move (4 queens example)"/></div></div><p class="title"><b>Figure 5.1. A single move (4 queens example)</b></p></div><br class="figure-break"/><p>A move can have a small or large impact. In the above example, the move of queen <span class="emphasis"><em>C0 to C2</em></span>
    is a small move. Some moves are the same move type. These are some possibilities for move types in n queens:</p><div class="itemizedlist"><ul><li><p>Move a single queen to another row. This is a small move. For example, move queen <span class="emphasis"><em>C0 to
        C2</em></span>.</p></li><li><p>Move all queens a number of rows down or up. This a big move.</p></li><li><p>Move a single queen to another column. This is a small move. For example, move queen <span class="emphasis"><em>C2 to
        A0</em></span> (placing it on top of queen A0).</p></li><li><p>Add a queen to the board at a certain row and column.</p></li><li><p>Remove a queen from the board.</p></li></ul></div><p>Because we have decided that all queens will be on the board at all times and each queen has an appointed
    column (for performance reasons), only the first 2 move types are usable in our example. Furthermore, we 're only
    using the first move type in the example because we think it gives the best performance, but you are welcome to
    prove us wrong.</p><p>Each of your move types will be an implementation of the <code class="literal">Move</code> interface:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Move</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isMoveDoable</span><span class="java_separator">(</span><span class="java_type">EvaluationHandler</span><span class="java_plain">&nbsp;evaluationHandler</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Move</span><span class="java_plain">&nbsp;createUndoMove</span><span class="java_separator">(</span><span class="java_type">EvaluationHandler</span><span class="java_plain">&nbsp;evaluationHandler</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;doMove</span><span class="java_separator">(</span><span class="java_type">EvaluationHandler</span><span class="java_plain">&nbsp;evaluationHandler</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Let's take a look at the <code class="literal">Move</code> implementation for 4 queens which moves a queen to a
    different row:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">YChangeMove</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">implements</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Move</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Queen</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">YChangeMove</span><span class="java_separator">(</span><span class="java_type">Queen</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">queen&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">toY&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;see&nbsp;below</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>An instance of <code class="literal">YChangeMove</code> moves a queen from its current y to a different y.</p><p>Drools Planner calls the <code class="literal">doMove(WorkingMemory)</code> method to do a move. The
    <code class="literal">Move</code> implementation must notify the working memory of any changes it does on the solution
    facts:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">void</span><!-- <br/> --><span class="java_plain">&nbsp;doMove</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">WorkingMemory</span><!-- <br/> --><span class="java_plain">&nbsp;workingMemory</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">FactHandle</span><span class="java_plain">&nbsp;queenHandle&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;workingMemory</span><span class="java_separator">.</span><span class="java_plain">getFactHandle</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queen</span><span class="java_separator">.</span><span class="java_plain">setY</span><span class="java_separator">(</span><span class="java_plain">toY</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workingMemory</span><span class="java_separator">.</span><span class="java_plain">update</span><span class="java_separator">(</span><span class="java_plain">queenHandle</span><span class="java_separator">,</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;after&nbsp;changes&nbsp;are&nbsp;made</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><p>You need to call the <code class="literal">workingMemory.update(FactHandle, Object)</code> method after modifying the
    fact. Note that you can alter multiple facts in a single move and effectively create a big move (also known as a
    coarse-grained move).</p><p>Drools Planner automatically filters out <span class="emphasis"><em>non doable moves</em></span> by calling the
    <code class="literal">isDoable(WorkingMemory)</code> method on a move. A <span class="emphasis"><em>non doable move</em></span> is:</p><div class="itemizedlist"><ul><li><p>A move that changes nothing on the current solution. For example, moving queen B0 to row 0 is not
        doable.</p></li><li><p>A move that is impossible to do on the current solution. For example, moving queen B0 to row 10 is not
        doable because it would move it outside the board limits.</p></li></ul></div><p>In the n queens example, a move which moves the queen from its current row to the same row isn't
    doable:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">boolean</span><!-- <br/> --><span class="java_plain">&nbsp;isMoveDoable</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">WorkingMemory</span><!-- <br/> --><span class="java_plain">&nbsp;workingMemory</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;fromY&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">.</span><span class="java_plain">getY</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;fromY&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><p>Because we won't generate a move which can move a queen outside the board limits, we don't need to check it. A
    move that is currently not doable can become doable on a later solution.</p><p>Each move has an <span class="emphasis"><em>undo move</em></span>: a move (usually of the same type) which does the exact
    opposite. In the above example the undo move of <span class="emphasis"><em>C0 to C2</em></span> would be the move <span class="emphasis"><em>C2 to
    C0</em></span>. An undo move can be created from a move, but only before the move has been done on the current
    solution.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Move</span><!-- <br/> --><span class="java_plain">&nbsp;createUndoMove</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">WorkingMemory</span><!-- <br/> --><span class="java_plain">&nbsp;workingMemory</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">YChangeMove</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">,</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">.</span><span class="java_plain">getY</span><span class="java_separator">());</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><p>Notice that if C0 would have already been moved to C2, the undo move would create the move <span class="emphasis"><em>C2 to
    C2</em></span>, instead of the move <span class="emphasis"><em>C2 to C0</em></span>.</p><p>The local search solver can do and undo a move more than once, even on different (successive)
    solutions.</p><p>A move must implement the <code class="literal">equals()</code> and <code class="literal">hashcode()</code> methods. 2 moves which
    make the same change on a solution, must be equal.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">boolean</span><!-- <br/> --><span class="java_plain">&nbsp;equals</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Object</span><!-- <br/> --><span class="java_plain">&nbsp;o</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_keyword">this</span><span class="java_plain">&nbsp;</span><span class="java_operator">==</span><span class="java_plain">&nbsp;o</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_literal">true</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span><span class="java_plain">&nbsp;</span><span class="java_keyword">else</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">o&nbsp;</span><span class="java_keyword">instanceof</span><span class="java_plain">&nbsp;</span><span class="java_type">YChangeMove</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">YChangeMove</span><span class="java_plain">&nbsp;other&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">YChangeMove</span><span class="java_separator">)</span><span class="java_plain">&nbsp;o</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">EqualsBuilder</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">append</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">,</span><span class="java_plain">&nbsp;other</span><span class="java_separator">.</span><span class="java_plain">queen</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">append</span><span class="java_separator">(</span><span class="java_plain">toY</span><span class="java_separator">,</span><span class="java_plain">&nbsp;other</span><span class="java_separator">.</span><span class="java_plain">toY</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">isEquals</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span><span class="java_plain">&nbsp;</span><span class="java_keyword">else</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;hashCode</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">HashCodeBuilder</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">append</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">append</span><span class="java_separator">(</span><span class="java_plain">toY</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">toHashCode</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><p>In the above example, the <code class="literal">Queen</code> class uses the default <code class="literal">Object</code>
    <code class="literal">equal()</code> and <code class="literal">hashcode()</code> implementations. Notice that it checks if the other
    move is an instance of the same move type. This is important because a move will be compared to a move with another
    move type if you're using more then 1 move type.</p><p>It's also recommended to implement the <code class="literal">toString()</code> method as it allows you to read Drools
    Planner's logging more easily:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">String</span><!-- <br/> --><span class="java_plain">&nbsp;toString</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;queen&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;=&gt;&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><p>Now that we can make a single move, let's take a look at generating moves.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1964"/>5.3. Move generation</h2></div></div></div><p>At each solution, local search will try all possible moves and pick the best move to change to the next
    solution. It's up to you to generate those moves. Let's take a look at all the possible moves on the starting
    solution of 4 queens:</p><div class="figure"><a id="d0e1969"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Local_search/possibleMovesNQueens04.png" alt="Possible moves at step 0 (4 queens example)"/></div></div><p class="title"><b>Figure 5.2. Possible moves at step 0 (4 queens example)</b></p></div><br class="figure-break"/><p>As you can see, not all the moves are doable. At the starting solution we have 12 doable moves (<code class="literal">n *
    (n - 1)</code>), one of which will be move which changes the starting solution into the next solution. Notice
    that the number of possible solutions is 256 (<code class="literal">n ^ n</code>), much more that the amount of doable moves.
    Don't create a move to every possible solution. Instead use moves which can be sequentially combined to reach every
    possible solution.</p><p>It's highly recommended that you verify all solutions are connected by your move set. This means that by
    combining a finite number of moves you can reach any solution from any solution. Otherwise you're already excluding
    solutions at the start. Especially if you're using only big moves, you should check it. Just because big moves
    outperform small moves in a short test run, it doesn't mean that they will outperform them in a long test
    run.</p><p>You can mix different move types. Usually you're better off preferring small (fine-grained) moves over big
    (course-grained) moves because the score delta calculation will pay off more. However, as the traveling tournament
    example proves, if you can remove a hard constraint by using a certain set of big moves, you can win performance and
    scalability. Try it yourself: run both the simple (small moves) and the smart (big moves) version of the traveling
    tournament example. The smart version evaluates a lot less unfeasible solutions, which enables it to outperform and
    outscale the simple version.</p><p>Move generation currently happens with a <code class="literal">MoveFactory</code>:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">NQueensMoveFactory</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">extends</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">CachedMoveListMoveFactory</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;</span><span class="java_type">Move</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;createMoveList</span><span class="java_separator">(</span><span class="java_type">Solution</span><span class="java_plain">&nbsp;solution</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">NQueens</span><span class="java_plain">&nbsp;nQueens&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">NQueens</span><span class="java_separator">)</span><span class="java_plain">&nbsp;solution</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;</span><span class="java_type">Move</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;moveList&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ArrayList</span><span class="java_operator">&lt;</span><span class="java_type">Move</span><span class="java_operator">&gt;</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Queen</span><span class="java_plain">&nbsp;queen&nbsp;</span><span class="java_operator">:</span><span class="java_plain">&nbsp;nQueens</span><span class="java_separator">.</span><span class="java_plain">getQueenList</span><span class="java_separator">())</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">int</span><span class="java_plain">&nbsp;n&nbsp;</span><span class="java_operator">:</span><span class="java_plain">&nbsp;nQueens</span><span class="java_separator">.</span><span class="java_plain">createNList</span><span class="java_separator">())</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveList</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">YChangeMove</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">,</span><span class="java_plain">&nbsp;n</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;moveList</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>But we might be making move generation part of the DRL's in the future.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1996"/>5.4. A step</h2></div></div></div><p>A step is the winning move. The local search solver tries every move on the current solution and picks the
    best accepted move as the step:</p><div class="figure"><a id="d0e2001"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Local_search/decideNextStepNQueens04.png" alt="Decide the next step at step 0 (4 queens example)"/></div></div><p class="title"><b>Figure 5.3. Decide the next step at step 0 (4 queens example)</b></p></div><br class="figure-break"/><p>Because the move <span class="emphasis"><em>B0 to B3</em></span> has the highest score (<code class="literal">-3</code>), it is picked as
    the next step. Notice that <span class="emphasis"><em>C0 to C3</em></span> (not shown) could also have been picked because it also has
    the score <code class="literal">-3</code>. If multiple moves have the same highest score, one is picked randomly, in this case
    <span class="emphasis"><em>B0 to B3</em></span>.</p><p>The step is made and from that new solution, the local search solver tries all the possible moves again, to
    decide the next step after that. It continually does this in a loop, and we get something like this:</p><div class="figure"><a id="d0e2026"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Local_search/allStepsNQueens04.png" alt="All steps (4 queens example)"/></div></div><p class="title"><b>Figure 5.4. All steps (4 queens example)</b></p></div><br class="figure-break"/><p>Notice that the local search solver doesn't use a search tree, but a search path. The search path is
    highlighted by the green arrows. At each step it tries all possible moves, but unless it's the step, it doesn't
    investigate that solution further. This is one of the reasons why local search is very scalable.</p><p>As you can see, the local search solver solves the 4 queens problem by starting with the starting solution and
    make the following steps sequentially:</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p><span class="emphasis"><em>B0 to B3</em></span></p></li><li><p><span class="emphasis"><em>D0 to B2</em></span></p></li><li><p><span class="emphasis"><em>A0 to B1</em></span></p></li></ol></div><p>If we turn on INFO logging, this is reflected into the logging:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">INFO  Solving with random seed (0).
INFO  Starting with time spend (0), score (-6), new best score (-6).
INFO  Step index (0), time spend (4), score (-3), new best score (-3), accepted move size (12) for picked step ([Queen-1] 1 @ 0 =&gt; 3).
INFO  Step index (1), time spend (7), score (-1), new best score (-1), accepted move size (12) for picked step ([Queen-0] 0 @ 0 =&gt; 1).
INFO  Step index (2), time spend (10), score (0), new best score (0), accepted move size (12) for picked step ([Queen-3] 3 @ 0 =&gt; 2).
INFO  Solved at step index (2) with time spend (10) for best score (0) with average calculate count per second (7300).</pre><p>Notice that the logging uses the <code class="literal">toString()</code> method of our <code class="literal">Move</code>
    implementation: <code class="literal">[Queen-1] 1 @ 0 =&gt; 3</code>.</p><p>The local search solver solves the 4 queens problem in 3 steps, by evaluating only 37 possible solutions (3
    steps with 12 moves each + 1 starting solution), which is only fraction of all 256 possible solutions. It solves 16
    queens in 31 steps, by evaluating only 7441 out of 18446744073709551616 possible solutions.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2066"/>5.5. Getting stuck in local optima</h2></div></div></div><p>A <span class="emphasis"><em>simple local search</em></span> always takes improving moves. This may seem like a good thing, but
    it's not. It suffers from a number of problems:</p><div class="itemizedlist"><ul><li><p>It can get stuck in a local optimum. For example if it reaches a solution X with a score -1 and there is
        no improving move, it is forced to take a next step that leads to a solution Y with score -2, after that
        however, it's very real that it will pick the step back to solution X with score -1. It will then start looping
        between solution X and Y.</p></li><li><p>It can start walking in its own footsteps, picking the same next step at every step.</p></li></ul></div><p>Of course Drools Planner implements better local searches, such as <span class="emphasis"><em>tabu search</em></span> and
    <span class="emphasis"><em>simulated annealing</em></span> which can avoid these problems. We recommend to never use a simple local
    search, unless you're absolutely sure there are no local optima in your planning problem.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2089"/>5.6. Deciding the next step</h2></div></div></div><p>The local search solver decides the next step with the aid of 3 configurable components:</p><div class="itemizedlist"><ul><li><p>A <span class="emphasis"><em>selector</em></span> which selects (or generates) the possible moves of the current
        solution.</p></li><li><p>An <span class="emphasis"><em>acceptor</em></span> which filters out unacceptable moves. It can also weigh a move it
        accepts.</p></li><li><p>A <span class="emphasis"><em>forager</em></span> which gathers all accepted moves and picks the next step from them.</p></li></ul></div><div class="figure"><a id="d0e2113"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Local_search/decideNextStepNQueens04.png" alt="Decide the next step at step 0 (4 queens example)"/></div></div><p class="title"><b>Figure 5.5. Decide the next step at step 0 (4 queens example)</b></p></div><br class="figure-break"/><p>In the above example the selector generated the moves shown with the blue lines, the acceptor accepted all of
    them and the forager picked the move <span class="emphasis"><em>B0 to B3</em></span>.</p><p>If we turn on DEBUG logging, we can see the decision making in the log:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
INFO  Solving with random seed (0).
INFO  Starting with time spend (0), score (-6), new best score (-6).
DEBUG     Ignoring not doable move ([Queen-0] 0 @ 0 =&gt; 0).
DEBUG     Move score (-4), accept chance (1.0) for move ([Queen-0] 0 @ 0 =&gt; 1).
DEBUG     Move score (-4), accept chance (1.0) for move ([Queen-0] 0 @ 0 =&gt; 2).
DEBUG     Move score (-4), accept chance (1.0) for move ([Queen-0] 0 @ 0 =&gt; 3).
...
DEBUG     Move score (-3), accept chance (1.0) for move ([Queen-1] 1 @ 0 =&gt; 3).
...
DEBUG     Move score (-3), accept chance (1.0) for move ([Queen-2] 2 @ 0 =&gt; 3).
...
DEBUG     Move score (-4), accept chance (1.0) for move ([Queen-3] 3 @ 0 =&gt; 3).
INFO  Step index (0), time spend (6), score (-3), new best score (-3), accepted move size (12) for picked step ([Queen-1] 1 @ 0 =&gt; 3).
...</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2128"/>5.6.1. Selector</h3></div></div></div><p>A selector is currently based on a <code class="literal">MoveFactory</code>.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.drools.planner.examples.nqueens.solver.NQueensMoveFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>You're not obligated to generate the same set of moves at each step. It's generally a good idea to use
      several selectors, mixing fine grained moves and course grained moves:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.drools.planner.examples.nurserostering.solver.move.factory.EmployeeChangeMoveFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.drools.planner.examples.nurserostering.solver.move.factory.AssignmentSwitchMoveFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.drools.planner.examples.nurserostering.solver.move.factory.AssignmentPillarPartSwitchMoveFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">moveFactoryClass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">selector</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2142"/>5.6.2. Acceptor</h3></div></div></div><p>An acceptor is used (together with a forager) to active tabu search, simulated annealing, great deluge, ...
      For each move it generates an accept chance. If a move is rejected it is given an accept chance of
      <code class="literal">0.0</code>.</p><p>You can implement your own <code class="literal">Acceptor</code>, although the build-in acceptors should suffice for
      most needs. You can also combine multiple acceptors.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2155"/>5.6.2.1. Tabu search acceptor</h4></div></div></div><p>When tabu search takes steps it creates tabu's. It does not accept a move as the next step if that move
        breaks tabu. Drools Planner implements several tabu types:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Solution tabu</em></span> makes recently visited solutions tabu. It does not accept a move
            that leads to one of those solutions. If you can spare the memory, don't be cheap on the tabu size. We
            recommend this type of tabu because it tends to give the best results and requires little or no
            tweaking.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completeSolutionTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completeSolutionTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li><li><p><span class="emphasis"><em>Move tabu</em></span> makes recent steps tabu. It does not accept a move equal to one of
            those steps.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completeMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">7</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completeMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li><li><p><span class="emphasis"><em>Undo move tabu </em></span>makes the undo move of recent steps tabu.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completeUndoMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">7</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completeUndoMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li><li><p><span class="emphasis"><em>Property tabu</em></span> makes a property of recent steps tabu. For example, it can make the
            queen tabu, so that a recently moved queen can't be moved.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completePropertyTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completePropertyTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>To use property tabu, your moves must implement the <code class="literal">TabuPropertyEnabled</code> interface,
            for example:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">YChangeMove</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">implements</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Move</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">TabuPropertyEnabled</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Queen</span><span class="java_plain">&nbsp;queen</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;toY</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">List</span><span class="java_operator">&lt;?</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Object</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTabuPropertyList</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_type">Collections</span><span class="java_separator">.</span><span class="java_plain">singletonList</span><span class="java_separator">(</span><span class="java_plain">queen</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>You can also make multiple properties tabu (with OR or AND semantics):</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_operator">&lt;?</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">extends</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Object</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;getTabuPropertyList</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;tabu&nbsp;with&nbsp;other&nbsp;moves&nbsp;that&nbsp;contain&nbsp;the&nbsp;same&nbsp;leftExam&nbsp;OR&nbsp;the&nbsp;same&nbsp;rightExam</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_type">Arrays</span><span class="java_separator">.</span><span class="java_plain">asList</span><span class="java_separator">(</span><span class="java_plain">leftExam</span><span class="java_separator">,</span><span class="java_plain">&nbsp;rightExam</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_operator">&lt;?</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">extends</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Object</span><!-- <br/> --><span class="java_operator">&gt;</span><!-- <br/> --><span class="java_plain">&nbsp;getTabuPropertyList</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;tabu&nbsp;with&nbsp;other&nbsp;moves&nbsp;that&nbsp;contain&nbsp;the&nbsp;same&nbsp;exam&nbsp;AND&nbsp;the&nbsp;same&nbsp;toPeriod&nbsp;</span><span class="java_separator">(</span><span class="java_plain">but&nbsp;not&nbsp;necessary&nbsp;the&nbsp;same&nbsp;toRoom</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_type">Collections</span><span class="java_separator">.</span><span class="java_plain">singletonList</span><span class="java_separator">(</span><span class="java_type">Arrays</span><span class="java_separator">.</span><span class="java_plain">asList</span><span class="java_separator">(</span><span class="java_plain">exam</span><span class="java_separator">,</span><span class="java_plain">&nbsp;toPeriod</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span></pre></li></ul></div><p>You can even combine tabu types:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completeSolutionTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completeSolutionTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completeMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">7</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completeMoveTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>If you pick a too small tabu size, your solver can still get stuck in a local optimum. On the other hand,
        with the exception of solution tabu, if you pick a too large tabu size, your solver can get stuck by bouncing of
        the walls. Use the benchmarker to fine tweak your configuration. Experiments teach us that it is generally best
        to use a prime number for the move tabu, undo move tabu or property tabu size.</p><p>A tabu search acceptor should be combined with a high or no subset selection.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2210"/>5.6.2.2. Simulated annealing acceptor</h4></div></div></div><p>Simulated annealing does not always pick the move with the highest score, neither does it evaluate many
        moves per step. At least at first. Instead, it gives unimproving moves also a chance to be picked, depending on
        its score and the time gradient of the <code class="literal">Termination</code>. In the end, it gradually turns into a
        simple local search, only accepting improving moves.</p><p>In many use cases, simulated annealing surpasses tabu search. By changing a few lines of configuration,
        you can easily switch from tabu search to simulated annealing and back.</p><p>Start with a <code class="literal">simulatedAnnealingStartingTemperature</code> set to the maximum score delta a
        single move can cause. Use the <code class="literal">Benchmarker</code> to tweak the value.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">simulatedAnnealingStartingTemperature</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">2hard/100soft</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">simulatedAnnealingStartingTemperature</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">4</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>A simulated annealing acceptor should be combined with a low subset selection. The classic algorithm uses
        a <code class="literal">minimalAcceptedSelection</code> of <code class="literal">1</code>, but usually <code class="literal">4</code> performs
        better.</p><p>You can even combine it with a tabu acceptor at the same time. Use a lower tabu size than in a pure tabu
        search configuration.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">simulatedAnnealingStartingTemperature</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">10.0</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">simulatedAnnealingStartingTemperature</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">completePropertyTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">completePropertyTabuSize</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">acceptor</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">4</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>This differs from phasing, another powerful technique, where first simulated annealing is used, followed
        by tabu search.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2247"/>5.6.3. Forager</h3></div></div></div><p>A forager gathers all accepted moves and picks the move which is the next step. Normally it picks the
      accepted move with the highest score. If several accepted moves have the highest score, one is picked randomly,
      weighted on their accept chance.</p><p>You can implement your own <code class="literal">Forager</code>, although the build-in forager should suffice for most
      needs.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2257"/>5.6.3.1. Subset selection</h4></div></div></div><p>When there are many possible moves, it becomes inefficient to evaluate all of them at every step. To
        evaluate only a random subset of all the moves, use:</p><div class="itemizedlist"><ul><li><p>An <code class="literal">minimalAcceptedSelection</code> integer, which specifies how many accepted moves should
            have be evaluated during each step. By default it is positive infinity, so all accepted moves are evaluated
            at every step.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1000</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">minimalAcceptedSelection</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li></ul></div><p>Unlike the n queens problem, real world problems require the use of subset selection. Start from an
        <code class="literal">minimalAcceptedSelection</code> that takes a step in less then 2 seconds. Turn on INFO logging to
        see the step times. Use the <code class="literal">Benchmarker</code> to tweak the value.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2279"/>5.6.3.2. Pick early type</h4></div></div></div><p>A forager can pick a move early during a step, ignoring subsequent selected moves. There are 3 pick early
        types:</p><div class="itemizedlist"><ul><li><p><code class="literal">NEVER</code>: A move is never picked early: all accepted moves are evaluated that the
            selection allows. This is the default.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">NEVER</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li><li><p><code class="literal">FIRST_BEST_SCORE_IMPROVING</code>: Pick the first accepted move that improves the best
            score. If none improve the best score, it behaves exactly like the pickEarlyType NEVER.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">FIRST_BEST_SCORE_IMPROVING</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li><li><p><code class="literal">FIRST_LAST_STEP_SCORE_IMPROVING</code>: Pick the first accepted move that improves the
            last step score. If none improve the last step score, it behaves exactly like the pickEarlyType
            NEVER.</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">FIRST_LAST_STEP_SCORE_IMPROVING</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">pickEarlyType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">forager</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></li></ul></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2306"/>5.7. Best solution</h2></div></div></div><p>Because the current solution can degrade (especially in tabu search and simulated annealing), the local search
    solver remembers the best solution it has encountered through the entire search path. Each time the current solution
    is better than the last best solution, the current solution is cloned and referenced as the new best
    solution.</p><p>You can listen to solver events, including when the best solution changes during solving, by adding a
    <code class="literal">SolverEventListener</code> to the <code class="literal">Solver</code>:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Solver</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;addEventListener</span><span class="java_separator">(</span><span class="java_type">SolverEventListener</span><span class="java_plain">&nbsp;eventListener</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;removeEventListener</span><span class="java_separator">(</span><span class="java_type">SolverEventListener</span><span class="java_plain">&nbsp;eventListener</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2321"/>5.8. Termination</h2></div></div></div><p>Sooner or later the local search solver will have to stop solving. This can be because of a number of reasons:
    the time is up, the perfect score has been reached, ... The only thing you can't depend on is on finding the optimal
    solution (unless you know the optimal score), because a local search algorithm doesn't know it when it finds the
    optimal solution. For real-life problems this doesn't turn out to be much of a problem, because finding the optimal
    solution would take billions of years, so you 'll want to terminate sooner anyway.</p><p>You can configure when a local search solver needs to stop by configuring a <code class="literal">Termination</code>. A
    <code class="literal">Termination</code> can calculate a time gradient, which is a ratio between the time already spend
    solving and the expected entire solving time.</p><p>You can implement your own <code class="literal">Termination</code>, although the build-in Terminations should suffice
    for most needs.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2339"/>5.8.1. TimeMillisSpendTermination</h3></div></div></div><p>Terminates when an amount of time has been reached:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumMinutesSpend</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">2</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumMinutesSpend</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>or</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumHoursSpend</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">1</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumHoursSpend</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Note that the time taken by a <code class="literal">StartingSolutionInitializer</code> also is taken into account by
      this Termination. So if you give the solver 2 minutes to solve something, but the initializer takes 1 minute, the
      local search solver will only have a minute left.</p><p>Note that if you use this Termination, you will most likely sacrifice reproducibility. The best solution
      will depend on available CPU time, not only because it influences the amount of steps taken, but also because time
      gradient based algorithms (such as simulated annealing) will probably act differently on each run.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2357"/>5.8.2. StepCountTermination</h3></div></div></div><p>Terminates when an amount of steps has been reached:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2364"/>5.8.3. ScoreAttainedTermination</h3></div></div></div><p>Terminates when a certain score has been reached. You can use this Termination if you know the perfect
      score, for example for 4 queens:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">0</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>You can also use this Termination to terminate once it reaches a feasible solution. For a solver problem
      with hard and soft constraints, it could look like this:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">0hard/-5000soft</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2375"/>5.8.4. UnimprovedStepCountTermination</h3></div></div></div><p>Terminates when the best score hasn't improved in a number of steps:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumUnimprovedStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumUnimprovedStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>If it hasn't improved recently, it's probably not going to improve soon anyway and it's not worth the effort
      to continue. We have observed that once a new best solution is found (even after a long time of no improvement on
      the best solution), the next few step tend to improve the best solution too.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2384"/>5.8.5. Combining Terminations</h3></div></div></div><p>Terminations can be combined, for example: terminate after 100 steps or if a score of 0 has been
      reached:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">terminationCompositionStyle</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">OR</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">terminationCompositionStyle</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">0</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Alternatively you can use AND, for example: terminate after reaching a feasible score of at least -100 and
      no improvements in 5 steps:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">terminationCompositionStyle</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">AND</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">terminationCompositionStyle</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">maximumUnimprovedStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">maximumUnimprovedStepCount</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">-100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreAttained</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">termination</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>This ensures it doesn't just terminate after finding a feasible solution, but also makes any obvious
      improvements on that solution before terminating.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2397"/>5.8.6. Another thread can ask a Solver to terminate early</h3></div></div></div><p>Sometimes you 'll want to terminate a Solver early from another thread, for example because a user action or
      a server restart. That cannot be configured by a <code class="literal">Termination</code> as it's impossible to predict when
      and if it will occur. Therefor the <code class="literal">Solver</code> interface has these 2 thread-safe methods:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Solver</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;terminateEarly</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isTerminatedEarly</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>If you call the <code class="literal">terminateEarly()</code> method from another thread, the
      <code class="literal">Solver</code> will terminate at its earliest convenience and the <code class="literal">solve()</code> method
      will return in the original solver thread.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2421"/>5.9. Using a custom Selector, Acceptor, Forager or Termination</h2></div></div></div><p>It is easy to plug in a custom <code class="literal">Selector</code>, <code class="literal">Acceptor</code>,
    <code class="literal">Forager</code> or <code class="literal">Termination</code> by extending the abstract class and also the config
    class.</p><p>For example, to use a custom <code class="literal">Selector</code>, extend the <code class="literal">AbstractSelector</code> class
    (see <code class="literal">AllMovesOfOneExamSelector</code>), extend the <code class="literal">SelectorConfig</code> class (see
    <code class="literal">AllMovesOfOneExamSelectorConfig</code>) and configure it in the configuration XML:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">selector</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.drools.planner.examples.examination.solver.selector.AllMovesOfOneExamSelectorConfig&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>If you build a better implementation that's not domain specific, consider adding it as a patch in our issue
    tracker and we'll take it along in future refactors and optimize it.</p></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch04.html"><strong>Prev</strong>Chapter 4. Score calculation with a rule engine</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="ch06.html"><strong>Next</strong>Chapter 6. Benchmarking and tweaking</a></li></ul></body></html>