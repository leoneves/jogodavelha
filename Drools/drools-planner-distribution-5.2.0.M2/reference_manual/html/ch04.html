<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 4. Score calculation with a rule engine</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Drools Planner User Guide"/><link rel="up" href="index.html" title="Drools Planner User Guide"/><link rel="prev" href="ch03.html" title="Chapter 3. Planner configuration"/><link rel="next" href="ch05.html" title="Chapter 5. Local search solver"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch03.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch05.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1491"/>Chapter 4. Score calculation with a rule engine</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch04.html#d0e1494">4.1. Rule based score calculation</a></span></dt><dt><span class="section"><a href="ch04.html#d0e1509">4.2. Defining the score rules source</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#d0e1514">4.2.1. A scoreDrl resource on the classpath</a></span></dt><dt><span class="section"><a href="ch04.html#d0e1529">4.2.2. A RuleBase (possibly defined by Guvnor)</a></span></dt></dl></dd><dt><span class="section"><a href="ch04.html#d0e1548">4.3. Implementing a score rule</a></span></dt><dt><span class="section"><a href="ch04.html#d0e1582">4.4. Delta based score calculation</a></span></dt><dt><span class="section"><a href="ch04.html#d0e1610">4.5. The ScoreDefinition interface</a></span></dt><dt><span class="section"><a href="ch04.html#d0e1695">4.6. Tips and tricks</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1494"/>4.1. Rule based score calculation</h2></div></div></div><p>The score calculation (or fitness function) of a planning problem is based on constraints (such as hard
    constraints, soft constraints, rewards, ...). A rule engine, such as Drools, makes it easy to implement those
    constraints as <span class="emphasis"><em>score rules</em></span>.</p><p><span class="bold"><strong>Adding more constraints is <span class="bold"><strong>easy and </strong></span>scalable</strong></span>
    (once you understand the DRL syntax). This allows you to add a bunch of soft constraint score rules on top of the
    hard constraints score rules with little effort and at a reasonable performance cost. For example, for a freight
    routing problem you could add a soft constraint to avoid the certain flagged highways during rush hour.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1509"/>4.2. Defining the score rules source</h2></div></div></div><p>There are 2 ways to define where your score rules live.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1514"/>4.2.1. A scoreDrl resource on the classpath</h3></div></div></div><p>This is the simplest way: the score rule live in a DRL file which is a resource on the classpath. Just add
      your score rules <code class="filename">*.drl</code> file in the solver configuration, for example:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreDrl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">/org/drools/planner/examples/nqueens/solver/nQueensScoreRules.drl</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreDrl</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>You can add multiple <code class="literal">&lt;scoreDrl&gt;</code> entries if needed, but normally you 'll define all
      your score rules in 1 file.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1529"/>4.2.2. A RuleBase (possibly defined by Guvnor)</h3></div></div></div><p>If you prefer to build the <code class="literal">RuleBase</code> yourself or if you're combining Planner with Guvnor,
      you can set the <code class="literal">RuleBase</code> on the <code class="literal">XmlSolverConfigurer</code> before building the
      <code class="literal">Solver</code>:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;xmlSolverConfigurer.getConfig().setRuleBase(ruleBase);</span><br />
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1548"/>4.3. Implementing a score rule</h2></div></div></div><p>The score calculation of a planning problem is based on constraints (such as hard constraints, soft
    constraints, rewards, ...). A rule engine, such as Drools, makes it easy to implement those constraints as
    <span class="emphasis"><em>score rules</em></span>.</p><p>Here's an example of a constraint implemented as a score rule in such a DRL file:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">rule "multipleQueensHorizontal"
    when
        $q1 : Queen($id : id, $y : y);
        $q2 : Queen(id &gt; $id, y == $y);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensHorizontal", $q1, $q2));
end</pre><p>This score rule will fire once for every 2 queens with the same <code class="literal">y</code>. The <code class="literal">(id &gt;
    $id)</code> condition is needed to assure that for 2 queens A and B, it can only fire for (A, B) and not for (B,
    A), (A, A) or (B, B). Let's take a closer look at this score rule on the starting solution of 4 queens:</p><div class="figure"><a id="d0e1568"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Score_calculation/unsolvedNQueens04.png" alt="Starting solution for the 4 queens puzzle"/></div></div><p class="title"><b>Figure 4.1. Starting solution for the 4 queens puzzle</b></p></div><br class="figure-break"/><p>In this starting solution the multipleQueensHorizontal score rule will fire for 6 queen couples: (A, B), (A,
    C), (A, D), (B, C), (B, D) and (C, D). Because none of the queens are on the same vertical or diagonal line, this
    starting solution will have a score of <code class="literal">-6</code>. An optimal solution of 4 queens has a score of
    <code class="literal">0</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1582"/>4.4. Delta based score calculation</h2></div></div></div><p>It's recommended to use Drools in forward-chaining mode (which is the default behaviour), as for score
    implementations this will create the effect of a <span class="emphasis"><em>delta based score calculation</em></span> instead of a
    full score calculation on each solution evaluation. For example, if a single queen A moves from y
    <code class="literal">0</code> to <code class="literal">3</code>, it won't bother to recalculate the "multiple queens on the same
    horizontal line" constraint between 2 queens if neither of those queens is queen A. This is a huge performance gain.
    <span class="bold"><strong>Drools Planner gives you this huge performance gain without forcing you to write a very
    complicated delta based score calculation algorithm.</strong></span> Just let the Drools rule engine do the hard
    work.</p><div class="figure"><a id="d0e1599"/><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Score_calculation/deltaBasedScoreCalculationNQueens04.png" alt="Delta based score calculation for the 4 queens puzzle"/></div></div><p class="title"><b>Figure 4.2. Delta based score calculation for the 4 queens puzzle</b></p></div><br class="figure-break"/><p>The speedup due to delta based score calculation is huge, because the speedup is relative to the size of your
    planning problem (your <span class="emphasis"><em>n</em></span>). By using score rules, you get that speedup without writing any delta
    code.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1610"/>4.5. The ScoreDefinition interface</h2></div></div></div><p>The <code class="literal">ScoreDefinition</code> interface defines the score representation. The score must a
    <code class="literal">Score</code> instance and the instance type (for example <code class="literal">DefaultHardAndSoftScore</code>)
    must be stable throughout the solver runtime.</p><p>The solver aims to find the solution with the highest score. <span class="emphasis"><em>The best solution</em></span> is the
    solution with the highest score that it has encountered during its solving.</p><p>Most planning problems tend to use negative scores (the amount of negative constraints being broken) with an
    impossible perfect score of 0. This explains why the score of a solution of 4 queens is the negative of the number
    of queen couples which can attack each other.</p><p>A <code class="literal">ScoreDefinition</code> instance is configured in the solver configuration:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreDefinition</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">scoreDefinitionType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">SIMPLE</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreDefinitionType</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">scoreDefinition</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>There are a couple of build-in <code class="literal">ScoreDefinition</code> implementations:</p><div class="itemizedlist"><ul><li><p>SIMPLE: The <code class="literal">SimpleScoreDefinition</code> defines the <code class="literal">Score</code> as a
        <code class="literal">SimpleScore</code> which has a single int value, for example <code class="literal">-123</code>.</p></li><li><p>HARD_AND_SOFT: The <code class="literal">HardAndSoftScoreDefinition</code> defines the <code class="literal">Score</code> as a
        <code class="literal">HardAndSoftScore</code> which has a hard int value and a soft int value, for example
        <code class="literal">-123hard/-456soft</code>.</p></li></ul></div><p>You can implement your own <code class="literal">ScoreDefinition</code>, although the build-in score definitions should
    suffice for most needs.</p><p>A <code class="literal">ScoreCalculator</code> instance is asserted into the working memory as a global called
    <code class="literal">scoreCalculator</code>. Your score rules need to (indirectly) update that instance. Usually you 'll make
    a single rule as an aggregation of the other rules to update the score:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">global SimpleScoreCalculator scoreCalculator;

rule "multipleQueensHorizontal"
    when
        $q1 : Queen($id : id, $y : y);
        $q2 : Queen(id &gt; $id, y == $y);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensHorizontal", $q1, $q2));
end

// multipleQueensVertical is obsolete because it is always 0

rule "multipleQueensAscendingDiagonal"
    when
        $q1 : Queen($id : id, $ascendingD : ascendingD);
        $q2 : Queen(id &gt; $id, ascendingD == $ascendingD);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensAscendingDiagonal", $q1, $q2));
end

rule "multipleQueensDescendingDiagonal"
    when
        $q1 : Queen($id : id, $descendingD : descendingD);
        $q2 : Queen(id &gt; $id, descendingD == $descendingD);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensDescendingDiagonal", $q1, $q2));
end

rule "hardConstraintsBroken"
    when
        $occurrenceCount : Number() from accumulate(
            $unweightedConstraintOccurrence : UnweightedConstraintOccurrence(),
            count($unweightedConstraintOccurrence)
        );
    then
        scoreCalculator.setScore(- $occurrenceCount.intValue());
end</pre><p>Optionally, you can also weigh your constraints differently, by multiplying the count of each score rule with
    its weight. For example in freight routing, you can make 5 broken "avoid crossroads" soft constraints count as much
    as 1 broken "avoid highways at rush hour" soft constraint. This allows your business analysts to easily tweak the
    score function as they see fit.</p><p>Here's an example of all the NQueens constraints written as a single rule, using multi pattern accumulates and
    making multipleQueensHorizontal constraint outweigh the other constraints 5 times:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">// Warning: This currently triggers backwards chaining instead of forward chaining and seriously hurts performance and scalability.
rule "constraintsBroken"
    when
        $multipleQueensHorizontal : Long()
        from accumulate(
            $q1 : Queen($id : id, $y : y)
            and Queen(id &gt; $id, y == $y),
           count($q1)
        );
        $multipleQueensAscendingDiagonal : Long()
        from accumulate(
            $q2 : Queen($id : id, $ascendingD : ascendingD)
            and Queen(id &gt; $id, ascendingD == $ascendingD),
           count($q2)
        );
        $multipleQueensDescendingDiagonal : Long()
        from accumulate(
            $q3 : Queen($id : id, $descendingD : descendingD)
            and Queen(id &gt; $id, descendingD == $descendingD),
           count($q3)
        );
    then
        scoreCalculator.setScore(- (5 * $multipleQueensHorizontal) - $multipleQueensAscendingDiagonal - $multipleQueensDescendingDiagonal);
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1695"/>4.6. Tips and tricks</h2></div></div></div><div class="itemizedlist"><ul><li><p>If you know a certain constraint can never be broken, don't bother writing a score rule for it. For
        example, the n queens example doesn't have a "multipleQueensVertical" rule because a queen's
        <code class="literal">x</code> never changes and the starting solution puts each queen on a different
        <code class="literal">x</code>. This tends to give a huge performance gain, not just because the score function is faster,
        but mainly because most solver implementations will spend less time evaluating unfeasible solutions.</p></li><li><p>Be watchfull for score traps. A score trap is a state in which several moves need to be done to resolve or
        lower the weight of a single constraint occurrence. Some examples of score traps:</p><div class="itemizedlist"><ul><li><p>If you need 2 doctors at each table, but you're only moving 1 doctor at a time, then the solver has no
            insentive to move a doctor to a table with no doctors. Punish a table with no doctors more then a table with
            only 1 doctor in your score function.</p></li><li><p>If you only add the table as a cause of the ConstraintOccurrence and forget the jobType (which is
            doctor or politician), then the solver has no insentive to move a docter to table which is short of a doctor
            and a politician.</p></li></ul></div></li><li><p>If you use tabu search, combine it with a <code class="literal">minimalAcceptedSelection</code> selector. Take some
        time to tweak the value of <code class="literal">minimalAcceptedSelection</code>.</p></li><li><p>Verify that your score calculation happens in the correct <code class="literal">Number</code> type. If you're making
        the sum of integer values, don't let drools use Double's or your performance will hurt. Solver implementations
        will usually spend most of their execution time running the score function.</p></li><li><p>Always remember that premature optimization is the root of all evil. Make sure your design is flexible
        enough to allow configuration based tweaking.</p></li><li><p>Currently, don't allow drools to backward chain instead of forward chain, so avoid query's. It kills
        scalibilty.</p></li><li><p>Currently, don't allow drools to switch to MVEL mode, for performance. You can avoid this by using
        <code class="literal">eval</code> in the score rules, for example: <code class="literal">eval(day.getIndex() == $day1.getIndex() +
        3)</code>.</p></li><li><p>For optimal performance, use at least java 1.6 and always use server mode (<code class="literal">java
        -server</code>). We have seen performance increases of 30% by switching from java 1.5 to 1.6 and 50% by
        turning on server mode.</p></li><li><p>If you're doing performance tests, always remember that the JVM needs to warm up. First load your solver
        and do a short run, before you start benchmarking it.</p></li></ul></div><p>In case you haven't figured it out yet: performance (and scalability) is very important for solving planning
    problems. What good is a real-time freight routing solver that takes a day to find a feasible solution? Even small
    and innocent looking problems can hide an enormous problem size. For example, they probably still don't know the
    optimal solution of the traveling tournament problem for as little as 10 traveling teams.</p></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch03.html"><strong>Prev</strong>Chapter 3. Planner configuration</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="ch05.html"><strong>Next</strong>Chapter 5. Local search solver</a></li></ul></body></html>